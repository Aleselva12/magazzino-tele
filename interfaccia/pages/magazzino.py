"""
magazzino.py  
Pagina gestione inventario magazzino con griglia Modelli x Colori
Sistema di visualizzazione e modifica quantità scorte
Generated by Copilot
"""

import tkinter as tk
from tkinter import ttk, messagebox
from typing import Dict, List, Any, Optional
import sys
import os

# Aggiungi il path del backend
sys.path.append(os.path.join(os.path.dirname(__file__), '..', '..', 'backend'))

try:
    from inventario_crud import InventarioCRUD
except ImportError:
    print("⚠️ Impossibile importare InventarioCRUD")
    InventarioCRUD = None

class MagazzinoPage:
    """
    Pagina principale per gestione inventario magazzino
    Griglia scrollabile Colori x Modelli con editing diretto (invertita)
    """
    
    def __init__(self, root: tk.Tk) -> None:
        self.root = root
        self.inventario_crud: Optional[InventarioCRUD] = None
        
        # Dati inventario (invertiti: colori come righe, modelli come colonne)
        self.colori: List[Dict[str, Any]] = []  # Righe
        self.modelli: List[Dict[str, Any]] = []  # Colonne
        self.quantita_data: Dict[str, int] = {}
        
        # Widgets principali
        self.main_frame: Optional[tk.Frame] = None
        self.canvas: Optional[tk.Canvas] = None
        self.scrollable_frame: Optional[tk.Frame] = None
        self.grid_frame: Optional[tk.Frame] = None
        
        # Entry widgets per editing quantità
        self.entry_widgets: Dict[str, tk.Entry] = {}
        
        # Configurazione colori alert
        self.soglia_minima = 5
        self.color_config = {
            'normale': '#FFFFFF',      # Bianco - scorte OK  
            'basso': '#FFF3CD',        # Giallo chiaro - scorte basse
            'esaurito': '#F8D7DA',     # Rosso chiaro - esaurito
            'negativo': '#E2E3E5'      # Grigio - quantità negative
        }
        
        self._init_backend()
        self._setup_ui()
        self._load_data()
    
    def _init_backend(self) -> None:
        """Inizializza connessione backend inventario"""
        try:
            if InventarioCRUD:
                self.inventario_crud = InventarioCRUD()
                if self.inventario_crud.connect():
                    print("✅ Backend inventario connesso")
                else:
                    print("❌ Errore connessione backend inventario")
            else:
                print("❌ Backend inventario non disponibile")
        except Exception as e:
            print(f"❌ Errore inizializzazione backend: {e}")
            self.inventario_crud = None
    
    def _setup_ui(self) -> None:
        """Configura interfaccia utente principale"""
        # Frame principale
        self.main_frame = ttk.Frame(self.root)
        self.main_frame.pack(fill="both", expand=True, padx=10, pady=10)
        
        # Configurazione stili
        self._setup_styles()
        
        # Header con titolo e controlli
        self._create_header()
        
        # Area griglia scrollabile
        self._create_scrollable_grid()
        
        # Footer con statistiche e controlli
        self._create_footer()
    
    def _setup_styles(self) -> None:
        """Configura stili personalizzati"""
        style = ttk.Style()
        
        # Stile header
        style.configure("Header.TLabel",
                       font=("Arial", 14, "bold"),
                       background="lightblue")
        
        # Stile bottoni
        style.configure("Action.TButton",
                       font=("Arial", 10),
                       padding=(10, 5))
    
    def _create_header(self) -> None:
        """Crea header con titolo e controlli"""
        if not self.main_frame:
            return
            
        header_frame = ttk.Frame(self.main_frame)
        header_frame.pack(fill="x", pady=(0, 10))
        
        # Titolo
        title_label = ttk.Label(
            header_frame,
            text="📦 Gestione Inventario Magazzino",
            style="Header.TLabel"
        )
        title_label.pack(side="left")
        
        # Controlli
        controls_frame = ttk.Frame(header_frame)
        controls_frame.pack(side="right")
        
        # Soglia minima
        ttk.Label(controls_frame, text="Soglia min:").pack(side="left", padx=(0, 5))
        
        self.soglia_var = tk.StringVar(value=str(self.soglia_minima))
        soglia_entry = ttk.Entry(controls_frame, textvariable=self.soglia_var, width=5)
        soglia_entry.pack(side="left", padx=(0, 10))
        soglia_entry.bind("<Return>", self._on_soglia_change)
        
        # Bottoni azioni
        ttk.Button(
            controls_frame,
            text="🔄 Ricarica",
            command=self._load_data,
            style="Action.TButton"
        ).pack(side="left", padx=(0, 5))
        
        ttk.Button(
            controls_frame,
            text="💾 Salva Tutto",
            command=self._save_all_changes,
            style="Action.TButton"
        ).pack(side="left", padx=(0, 5))
        
        ttk.Button(
            controls_frame,
            text="⚠️ Alert Scorte",
            command=self._show_stock_alerts,
            style="Action.TButton"
        ).pack(side="left")
    
    def _create_scrollable_grid(self) -> None:
        """Crea area griglia scrollabile"""
        if not self.main_frame:
            return
            
        # Frame container per scrolling
        container_frame = ttk.Frame(self.main_frame)
        container_frame.pack(fill="both", expand=True)
        
        # Canvas per scrolling
        self.canvas = tk.Canvas(container_frame, bg="white")
        self.canvas.pack(side="left", fill="both", expand=True)
        
        # Scrollbars
        v_scrollbar = ttk.Scrollbar(container_frame, orient="vertical", command=self.canvas.yview)
        v_scrollbar.pack(side="right", fill="y")
        
        h_scrollbar = ttk.Scrollbar(self.main_frame, orient="horizontal", command=self.canvas.xview)
        h_scrollbar.pack(side="bottom", fill="x")
        
        # Configura canvas
        self.canvas.configure(yscrollcommand=v_scrollbar.set, xscrollcommand=h_scrollbar.set)
        
        # Frame scrollabile interno
        self.scrollable_frame = ttk.Frame(self.canvas)
        self.canvas_window = self.canvas.create_window((0, 0), window=self.scrollable_frame, anchor="nw")
        
        # Bind eventi scroll
        self.scrollable_frame.bind("<Configure>", self._on_frame_configure)
        self.canvas.bind("<Configure>", self._on_canvas_configure)
        self.canvas.bind_all("<MouseWheel>", self._on_mousewheel)
    
    def _create_footer(self) -> None:
        """Crea footer con statistiche"""
        if not self.main_frame:
            return
            
        footer_frame = ttk.Frame(self.main_frame)
        footer_frame.pack(fill="x", pady=(10, 0))
        
        # Area statistiche
        self.stats_label = ttk.Label(
            footer_frame,
            text="📊 Caricamento dati...",
            font=("Arial", 9)
        )
        self.stats_label.pack(side="left")
        
        # Legenda colori
        legend_frame = ttk.Frame(footer_frame)
        legend_frame.pack(side="right")
        
        legend_items = [
            ("🟢 Normale", self.color_config['normale']),
            ("🟡 Basso", self.color_config['basso']),
            ("🔴 Esaurito", self.color_config['esaurito']),
            ("⚫ Negativo", self.color_config['negativo'])
        ]
        
        for text, color in legend_items:
            label = tk.Label(legend_frame, text=text, bg=color, relief="solid", borderwidth=1)
            label.pack(side="left", padx=2)
    
    def _load_data(self) -> None:
        """Carica dati inventario dal database"""
        if not self.inventario_crud:
            messagebox.showerror("Errore", "Backend non disponibile")
            return
        
        try:
            # Carica dati griglia (invertiti: colori come righe, modelli come colonne)
            data = self.inventario_crud.get_inventario_grid()
            self.colori = data.get('colori', [])  # Righe
            self.modelli = data.get('modelli', [])  # Colonne
            self.quantita_data = data.get('quantita', {})
            
            # Crea griglia
            self._create_inventory_grid()
            
            # Aggiorna statistiche
            self._update_statistics()
            
            print(f"✅ Caricati {len(self.colori)} colori, {len(self.modelli)} modelli")
            
        except Exception as e:
            messagebox.showerror("Errore", f"Errore caricamento dati: {str(e)}")
            print(f"❌ Errore caricamento: {e}")
    
    def _create_inventory_grid(self) -> None:
        """Crea griglia inventario Colori x Modelli (invertita)"""
        if not self.scrollable_frame:
            return
        
        # Pulisci frame esistente
        for widget in self.scrollable_frame.winfo_children():
            widget.destroy()
        
        self.entry_widgets.clear()
        
        # Crea nuovo grid frame
        self.grid_frame = ttk.Frame(self.scrollable_frame)
        self.grid_frame.pack(fill="both", expand=True, padx=10, pady=10)
        
        if not self.colori or not self.modelli:
            ttk.Label(self.grid_frame, text="📭 Nessun dato disponibile").pack()
            return
        
        # Header riga - Modelli (come colonne)
        ttk.Label(self.grid_frame, text="Colore \\ Modello", font=("Arial", 10, "bold")).grid(
            row=0, column=0, padx=2, pady=2, sticky="nsew"
        )
        
        # Header colonne - Modelli
        for col_idx, modello in enumerate(self.modelli, 1):
            model_text = f"M{modello['codice_modello']}"
            label = ttk.Label(self.grid_frame, text=model_text, font=("Arial", 9, "bold"))
            label.grid(row=0, column=col_idx, padx=1, pady=1, sticky="nsew")
        
        # Righe dati - Colori (come righe)
        for row_idx, colore in enumerate(self.colori, 1):
            # Header colonna - Colore
            color_text = f"{colore['codice_colore']} - {colore['nome_colore']}"
            label = ttk.Label(self.grid_frame, text=color_text, font=("Arial", 9, "bold"))
            label.grid(row=row_idx, column=0, padx=2, pady=1, sticky="w")
            
            # Celle quantità (colore x modello)
            for col_idx, modello in enumerate(self.modelli, 1):
                self._create_quantity_cell(row_idx, col_idx, colore, modello)
        
        # Configura peso colonne per ridimensionamento
        for i in range(len(self.modelli) + 1):
            self.grid_frame.columnconfigure(i, weight=1)
    
    def _create_quantity_cell(self, row: int, col: int, colore: Dict[str, Any], modello: Dict[str, Any]) -> None:
        """Crea cella modificabile per quantità (invertito: colore x modello)"""
        if not self.grid_frame:
            return
            
        codice_colore = colore['codice_colore']
        codice_modello = modello['codice_modello']
        
        # Trova codice prodotto e quantità attuale
        current_qty = self._get_current_quantity(codice_modello, codice_colore)
        
        # Crea Entry widget
        qty_var = tk.StringVar(value=str(current_qty))
        entry = tk.Entry(
            self.grid_frame,
            textvariable=qty_var,
            width=8,
            justify="center",
            font=("Arial", 9)
        )
        
        # Posiziona entry
        entry.grid(row=row, column=col, padx=1, pady=1, sticky="nsew")
        
        # Configura colore background basato su quantità
        bg_color = self._get_quantity_color(current_qty)
        entry.configure(bg=bg_color)
        
        # Bind eventi
        entry.bind("<FocusOut>", lambda e, m=codice_modello, c=codice_colore: self._on_quantity_change(e, m, c))
        entry.bind("<Return>", lambda e, m=codice_modello, c=codice_colore: self._on_quantity_change(e, m, c))
        
        # Salva riferimento
        key = f"{codice_modello}_{codice_colore}"
        self.entry_widgets[key] = entry
    
    def _get_current_quantity(self, codice_modello: int, codice_colore: int) -> int:
        """Recupera quantità attuale per modello-colore"""
        if not self.inventario_crud:
            return 0
        
        try:
            return self.inventario_crud.get_quantita_by_modello_colore(codice_modello, codice_colore)
        except Exception as e:
            print(f"❌ Errore recupero quantità {codice_modello}-{codice_colore}: {e}")
            return 0
    
    def _get_quantity_color(self, quantity: int) -> str:
        """Determina colore background basato su quantità"""
        if quantity < 0:
            return self.color_config['negativo']
        elif quantity == 0:
            return self.color_config['esaurito']
        elif quantity <= self.soglia_minima:
            return self.color_config['basso']
        else:
            return self.color_config['normale']
    
    def _on_quantity_change(self, event: tk.Event, codice_modello: int, codice_colore: int) -> None:
        """Gestisce cambio quantità in cella"""
        entry = event.widget
        
        try:
            new_qty = int(entry.get())
            
            # Aggiorna database
            if self.inventario_crud and self.inventario_crud.update_quantita(codice_modello, codice_colore, new_qty):
                # Aggiorna colore background
                bg_color = self._get_quantity_color(new_qty)
                entry.configure(bg=bg_color)
                
                # Aggiorna statistiche
                self._update_statistics()
                
                print(f"✅ Aggiornata quantità modello {codice_modello} colore {codice_colore}: {new_qty}")
            else:
                messagebox.showerror("Errore", "Impossibile aggiornare quantità")
                
        except ValueError:
            messagebox.showerror("Errore", "Inserire un numero valido")
            entry.focus_set()
        except Exception as e:
            messagebox.showerror("Errore", f"Errore aggiornamento: {str(e)}")
    
    def _on_soglia_change(self, event: tk.Event) -> None:
        """Gestisce cambio soglia minima"""
        try:
            self.soglia_minima = int(self.soglia_var.get())
            self._refresh_colors()
        except ValueError:
            messagebox.showerror("Errore", "Soglia deve essere un numero")
    
    def _refresh_colors(self) -> None:
        """Aggiorna colori celle basato su nuova soglia"""
        for key, entry in self.entry_widgets.items():
            try:
                qty = int(entry.get())
                bg_color = self._get_quantity_color(qty)
                entry.configure(bg=bg_color)
            except ValueError:
                pass
    
    def _save_all_changes(self) -> None:
        """Salva tutte le modifiche pendenti"""
        # Per ora solo mostra messaggio - le modifiche sono già salvate in tempo reale
        messagebox.showinfo("Info", "Le modifiche sono salvate automaticamente ad ogni cambio")
    
    def _show_stock_alerts(self) -> None:
        """Mostra finestra alert scorte basse"""
        if not self.inventario_crud:
            messagebox.showerror("Errore", "Backend non disponibile")
            return
        
        try:
            alerts = self.inventario_crud.get_stock_alerts(self.soglia_minima)
            
            if not alerts:
                messagebox.showinfo("Scorte", "✅ Tutte le scorte sono sopra la soglia minima")
                return
            
            # Crea finestra alert
            alert_window = tk.Toplevel(self.root)
            alert_window.title("⚠️ Alert Scorte Basse")
            alert_window.geometry("600x400")
            
            # Lista alert
            frame = ttk.Frame(alert_window)
            frame.pack(fill="both", expand=True, padx=10, pady=10)
            
            ttk.Label(frame, text="⚠️ Prodotti con scorte sotto soglia", font=("Arial", 12, "bold")).pack(pady=(0, 10))
            
            # Treeview per alert
            columns = ('Modello', 'Colore', 'Quantità', 'Codice Prodotto')
            tree = ttk.Treeview(frame, columns=columns, show='headings')
            
            for col in columns:
                tree.heading(col, text=col)
                tree.column(col, width=120)
            
            for alert in alerts:
                tree.insert('', 'end', values=(
                    alert['descrizione_modello'],
                    alert['descrizione_colore'],
                    alert['quantita'],
                    alert['codice_prodotto']
                ))
            
            tree.pack(fill="both", expand=True)
            
        except Exception as e:
            messagebox.showerror("Errore", f"Errore recupero alert: {str(e)}")
    
    def _update_statistics(self) -> None:
        """Aggiorna statistiche footer"""
        if not hasattr(self, 'stats_label'):
            return
        
        try:
            total_products = len(self.modelli) * len(self.colori)
            
            # Conta prodotti per categoria
            normal_count = 0
            low_count = 0
            empty_count = 0
            negative_count = 0
            
            for modello in self.modelli:
                for colore in self.colori:
                    qty = self._get_current_quantity(modello['codice_modello'], colore['codice_colore'])
                    if qty < 0:
                        negative_count += 1
                    elif qty == 0:
                        empty_count += 1
                    elif qty <= self.soglia_minima:
                        low_count += 1
                    else:
                        normal_count += 1
            
            stats_text = f"📊 Prodotti: {total_products} | ✅ Normali: {normal_count} | ⚠️ Bassi: {low_count} | ❌ Esauriti: {empty_count} | ⚫ Negativi: {negative_count}"
            self.stats_label.configure(text=stats_text)
            
        except Exception as e:
            print(f"❌ Errore aggiornamento statistiche: {e}")
    
    # Event handlers per scrolling
    def _on_frame_configure(self, event: tk.Event) -> None:
        """Aggiorna scroll region quando frame cambia"""
        if self.canvas:
            self.canvas.configure(scrollregion=self.canvas.bbox("all"))
    
    def _on_canvas_configure(self, event: tk.Event) -> None:
        """Aggiorna dimensioni frame scrollabile"""
        if self.canvas and self.scrollable_frame:
            canvas_width = event.width
            self.canvas.itemconfig(self.canvas_window, width=canvas_width)
    
    def _on_mousewheel(self, event: tk.Event) -> None:
        """Gestisce scroll con mouse wheel"""
        if self.canvas:
            self.canvas.yview_scroll(int(-1 * (event.delta / 120)), "units")

# Funzione helper per testing
def main():
    """Test della pagina magazzino"""
    root = tk.Tk()
    root.title("Test Magazzino")
    root.geometry("1200x800")
    
    app = MagazzinoPage(root)
    root.mainloop()

if __name__ == "__main__":
    main()
